name: "Terraform CI/CD"

on:
  push:
    branches:
      - dev

permissions:
  contents: read
  id-token: write

jobs:
  terraform-ecr:
    name: "Terraform ECR"
    runs-on: ubuntu-latest
    outputs:
      ecr_repository_url: ${{ steps.output.outputs.ecr_repository_url }}
    steps:
      # Your steps to create ECR and set output
      - name: Set ECR Output
        id: output
        run: echo "ecr_repository_url=${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/cloud-file-manager-backend" >> $GITHUB_OUTPUT

  build-and-push-docker:
    name: "Build and Push Docker Image"
    needs: terraform-ecr
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build, tag, and push image to Amazon ECR
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: "${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/cloud-file-manager-backend"
          IMAGE_TAG: latest
        run: |
          cd cloud-file-manager-backend
          docker build -t $ECR_REPOSITORY:$IMAGE_TAG -f Dockerfile .
          docker push $ECR_REPOSITORY:$IMAGE_TAG

  terraform-apply:
    name: "Terraform Apply"
    needs: build-and-push-docker
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash
        working-directory: ./terraform

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-role
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.8.5

      - name: Terraform Init
        run: |
          terraform init \
          -backend-config="bucket=${{ secrets.PROJECT_NAME }}-${{ secrets.ENVIRONMENT }}-terraform-state" \
          -backend-config="key=${{ secrets.PROJECT_NAME }}/${{ secrets.ENVIRONMENT }}/terraform.tfstate" \
          -backend-config="region=${{ secrets.AWS_REGION }}" \
          -backend-config="dynamodb_table=${{ secrets.PROJECT_NAME }}-${{ secrets.ENVIRONMENT }}-terraform-locks"

      - name: Check and Import Existing Resources
        id: check_import_resources
        env:
          PROJECT_NAME: ${{ secrets.PROJECT_NAME }}
          ENVIRONMENT: ${{ secrets.ENVIRONMENT }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -e
          
          # CloudWatch Log Group
          LOG_GROUP_NAME="/aws/ec2/${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}"
          if aws logs describe-log-groups --log-group-name-prefix "$LOG_GROUP_NAME" --query "logGroups[?logGroupName==`$LOG_GROUP_NAME`].logGroupName" --output text --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "CloudWatch Log Group $LOG_GROUP_NAME already exists. Importing."
            terraform import aws_cloudwatch_log_group.app_log_group "$LOG_GROUP_NAME"
          else
            echo "CloudWatch Log Group $LOG_GROUP_NAME does not exist. Terraform will create it."
          fi

          # Secrets Manager Secrets
          ACCESS_SECRET_NAME="${{ env.ENVIRONMENT }}/jwt/accessSecret"
          if aws secretsmanager describe-secret --secret-id "$ACCESS_SECRET_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Secrets Manager Secret $ACCESS_SECRET_NAME already exists. Importing."
            terraform import aws_secretsmanager_secret.jwt_access_secret "$ACCESS_SECRET_NAME"
          else
            echo "Secrets Manager Secret $ACCESS_SECRET_NAME does not exist. Terraform will create it."
          fi

          REFRESH_SECRET_NAME="${{ env.ENVIRONMENT }}/jwt/refreshSecret"
          if aws secretsmanager describe-secret --secret-id "$REFRESH_SECRET_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Secrets Manager Secret $REFRESH_SECRET_NAME already exists. Importing."
            terraform import aws_secretsmanager_secret.jwt_refresh_secret "$REFRESH_SECRET_NAME"
          else
            echo "Secrets Manager Secret $REFRESH_SECRET_NAME does not exist. Terraform will create it."
          fi

          FILE_ENCRYPTION_KEY_NAME="${{ env.ENVIRONMENT }}/file/encryptionKey"
          if aws secretsmanager describe-secret --secret-id "$FILE_ENCRYPTION_KEY_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "Secrets Manager Secret $FILE_ENCRYPTION_KEY_NAME already exists. Importing."
            terraform import aws_secretsmanager_secret.file_encryption_key "$FILE_ENCRYPTION_KEY_NAME"
          else
            echo "Secrets Manager Secret $FILE_ENCRYPTION_KEY_NAME does not exist. Terraform will create it."
          fi

          # ELBv2 Load Balancer (ALB)
          ALB_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-alb"
          if aws elbv2 describe-load-balancers --names "$ALB_NAME" --query "LoadBalancers[0].LoadBalancerArn" --output text --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            ALB_ARN=$(aws elbv2 describe-load-balancers --names "$ALB_NAME" --query "LoadBalancers[0].LoadBalancerArn" --output text --region ${{ env.AWS_REGION }})
            echo "ALB $ALB_NAME already exists. Importing."
            terraform import module.alb.aws_lb.main "$ALB_ARN"
          else
            echo "ALB $ALB_NAME does not exist. Terraform will create it."
          fi

          # ELBv2 Target Group
          TG_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-tg"
          if aws elbv2 describe-target-groups --names "$TG_NAME" --query "TargetGroups[0].TargetGroupArn" --output text --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            TG_ARN=$(aws elbv2 describe-target-groups --names "$TG_NAME" --query "TargetGroups[0].TargetGroupArn" --output text --region ${{ env.AWS_REGION }})
            echo "Target Group $TG_NAME already exists. Importing."
            terraform import module.alb.aws_lb_target_group.main "$TG_ARN"
          else
            echo "Target Group $TG_NAME does not exist. Terraform will create it."
          fi

          # ElastiCache Subnet Group
          ELASTICACHE_SUBNET_GROUP_NAME="${{ env.PROJECT_NAME }}-subnet-group"
          if aws elasticache describe-cache-subnet-groups --cache-subnet-group-name "$ELASTICACHE_SUBNET_GROUP_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "ElastiCache Subnet Group $ELASTICACHE_SUBNET_GROUP_NAME already exists. Importing."
            terraform import module.elasticache.aws_elasticache_subnet_group.main "$ELASTICACHE_SUBNET_GROUP_NAME"
          else
            echo "ElastiCache Subnet Group $ELASTICACHE_SUBNET_GROUP_NAME does not exist. Terraform will create it."
          fi

          # IAM Role
          IAM_ROLE_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-ec2-role"
          if aws iam get-role --role-name "$IAM_ROLE_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "IAM Role $IAM_ROLE_NAME already exists. Importing."
            terraform import module.iam.aws_iam_role.ec2_role "$IAM_ROLE_NAME"
          else
            echo "IAM Role $IAM_ROLE_NAME does not exist. Terraform will create it."
          fi

          # RDS DB Subnet Group
          RDS_SUBNET_GROUP_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-rds-subnet-group"
          if aws rds describe-db-subnet-groups --db-subnet-group-name "$RDS_SUBNET_GROUP_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "RDS DB Subnet Group $RDS_SUBNET_GROUP_NAME already exists. Importing."
            terraform import module.rds.aws_db_subnet_group.main "$RDS_SUBNET_GROUP_NAME"
          else
            echo "RDS DB Subnet Group $RDS_SUBNET_GROUP_NAME does not exist. Terraform will create it."
          fi

          # S3 Bucket
          S3_BUCKET_NAME="${{ env.PROJECT_NAME }}-${{ env.ENVIRONMENT }}-uploads-bucket"
          if aws s3api head-bucket --bucket "$S3_BUCKET_NAME" --region ${{ env.AWS_REGION }} > /dev/null 2>&1; then
            echo "S3 Bucket $S3_BUCKET_NAME already exists. Importing."
            terraform import module.s3.aws_s3_bucket.main "$S3_BUCKET_NAME"
          else
            echo "S3 Bucket $S3_BUCKET_NAME does not exist. Terraform will create it."
          fi

          echo "Finished checking and importing existing resources."

      - name: Terraform Apply All
        env:
          TF_VAR_project_name: ${{ secrets.PROJECT_NAME }}
          TF_VAR_environment: ${{ secrets.ENVIRONMENT }}
          TF_VAR_aws_region: ${{ secrets.AWS_REGION }}
          TF_VAR_db_username: ${{ secrets.DB_USERNAME }}
        run: |
          echo "db_password = \"${{ secrets.DB_PASSWORD }}\"" > terraform.tfvars.tmp
          echo "jwt_access_secret = \"${{ secrets.JWT_ACCESS_SECRET }}\"" >> terraform.tfvars.tmp
          echo "jwt_refresh_secret = \"${{ secrets.JWT_REFRESH_SECRET }}\"" >> terraform.tfvars.tmp
          echo "file_name_encryption_key = \"${{ secrets.FILE_NAME_ENCRYPTION_KEY }}\"" >> terraform.tfvars.tmp
          
          terraform apply -auto-approve -var-file=terraform.tfvars.tmp -replace="module.ec2_api.aws_instance.app_instance[0]" -replace="module.ec2_workers.aws_instance.app_instance[0]"
          rm terraform.tfvars.tmp

      - name: Set Terraform Outputs
        id: output
        run: |
          echo "application_url=$(terraform output -raw application_url)" >> $GITHUB_OUTPUT
